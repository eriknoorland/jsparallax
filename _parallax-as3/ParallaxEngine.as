/** * @package nl.eriknoorland.parallax */package nl.eriknoorland.parallax{	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import nl.eriknoorland.parallax.Behaviour;	import nl.eriknoorland.parallax.Axis;	import nl.eriknoorland.parallax.View;	import nl.eriknoorland.parallax.State;		public class ParallaxEngine extends Sprite{		protected var _view:View;		protected var _focus:int;		protected var _behaviour:Behaviour;		protected var _state:String = State.PAUSE;		protected var _elements:Array = new Array;		protected var _container:Sprite = new Sprite;		private var _numElements:int;				/**		 * ParallaxEngine - Constructor		 * @param View - The viewport of the parallax engine		 * @param int - The focus, or focal point		 * @param Behaviour [optional] - The behaviour of the parallax engine elements		 */		public function ParallaxEngine(v:View, f:int, b:Behaviour = null){			_view = v;			_focus = f;			if(b == null) b = new Behaviour;			_behaviour = b;			addChild(_container);		}				/**		 * Sets the behaviour of the parallax engine elements		 * @param Behaviour		 * @return void		 */		public function set behaviour(b:Behaviour):void{			_behaviour = b;		}				/**		 * Sets the state of the parallax engine. Options are: State.RUN or State.PAUSE. The default value is State.PAUSE		 * @param String		 * @return void		 */		public function set state(s:String):void{			switch(s){				case State.RUN:{					if(!hasEventListener(Event.ENTER_FRAME)) addEventListener(Event.ENTER_FRAME, handleEnterFrame);					_state = s;					break;				}				case State.PAUSE:{					if(hasEventListener(Event.ENTER_FRAME)) removeEventListener(Event.ENTER_FRAME, handleEnterFrame);					_state = s;					break;				}			}		}				/**		 * Adds a display object to the parallax engine		 * @param DisplayObject		 * @param int		 * @return void		 */		public function addElement(dO:DisplayObject, d:int):void{			_container.addChild(dO);			_elements.push({displayObject:dO, point:new Point(dO.x, dO.y), depth:d});			_numElements = _elements.length;		}				/**		 * Removes a display object from the parallax engine		 * @param DisplayObject		 * @return void		 */		public function removeElement(dO:DisplayObject):void{			for(var i:int = 0; i < _numElements; i++){				if(_elements[i].displayObject as DisplayObject == dO){					_elements.splice(i, 1);					_container.removeChild(dO);					break;				}			}			_numElements = _elements.length;		}				/**		 * Handles the ENTER_FRAME event		 * @param Event		 * @return void		 */		protected function handleEnterFrame(e:Event):void{			var mX:Number = _behaviour.target.x;			var mY:Number = _behaviour.target.y;			if((mX < _view.boundLeft || mX > _view.boundRight || mY < _view.boundTop || mY > _view.boundBottom) && _behaviour.outOfBounds != Behaviour.CONTINUE_TO_DESTINATION){				if(_behaviour.outOfBounds == Behaviour.STOP_MOVEMENT) return;				mX = _view.width/2;				mY = _view.height/2;			}			else if(mX < _view.boundLeft && _behaviour.outOfBounds == Behaviour.CONTINUE_TO_DESTINATION) mX = _view.boundLeft;			else if(mX > _view.boundRight && _behaviour.outOfBounds == Behaviour.CONTINUE_TO_DESTINATION) mX = _view.boundRight;			else if(mY < _view.boundTop && _behaviour.outOfBounds == Behaviour.CONTINUE_TO_DESTINATION) mY = _view.boundTop;			else if(mY > _view.boundBottom && _behaviour.outOfBounds == Behaviour.CONTINUE_TO_DESTINATION) mY = _view.boundBottom;						for(var i:int = 0; i < _numElements; i++){				var el:DisplayObject = _elements[i].displayObject as DisplayObject;				var d:int = _elements[i].depth;				var p:Point = _elements[i].point;				//if(_behaviour.axis == Axis.X || _behaviour.axis == Axis.BOTH) el.x += ((((((_view.width/2)-mX)/_focus)*(_focus-d)*(_behaviour.invert == Axis.X || _behaviour.invert == Axis.BOTH ? -1 : 1))+p.x)-el.x)*_behaviour.ease;	 			//if(_behaviour.axis == Axis.Y || _behaviour.axis == Axis.BOTH) el.y += ((((((_view.height/2)-mY)/_focus)*(_focus-d)*(_behaviour.invert == Axis.Y || _behaviour.invert == Axis.BOTH ? -1 : 1))+p.y)-el.y)*_behaviour.ease;				if(_behaviour.axis == Axis.X || _behaviour.axis == Axis.BOTH) el.x += (((((((stage.stageWidth/2)-mX)/_focus)*(_focus-d)*(_behaviour.invert == Axis.X || _behaviour.invert == Axis.BOTH ? -1 : 1))+p.x)-el.x)*_behaviour.ease)*(_view.width/stage.stageWidth);	 			if(_behaviour.axis == Axis.Y || _behaviour.axis == Axis.BOTH) el.y += (((((((stage.stageHeight/2)-mY)/_focus)*(_focus-d)*(_behaviour.invert == Axis.Y || _behaviour.invert == Axis.BOTH ? -1 : 1))+p.y)-el.y)*_behaviour.ease)*(_view.height/stage.stageHeight);			}		}	}}